<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JPA动态查询]]></title>
    <url>%2F2018%2F11%2F24%2FJPA%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[动态查询是更具面向对象特色的数据查询方式，Hiberbnate放弃了Criteria,Criterion组成的动态条件查询，全面改为使用JPA的动态条件查询 JPAJPA规范本质就是一种ORM规范（对象关系映射Object Relational Mapping ），但并未提供ORM实现只是制定了一些规范，也就是说JPA提供的只是一些接口，Hibernate就是一种ORM实现，下面是JPA的核心API EntityManagerFactory对应Hibernate的SessionFactory EntityManager对应Hibernate的Session EntityTransaction对应Hibernate的TransactionJPA使用类路径下的META-INF子目录中的persistence.xml作为配置文件，格式如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;persistence version=&quot;2.1&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd&quot;&gt; &lt;!-- 为持久化单元指定名称，并通过transaction-type指定事务类型 transaction-type属性合法的属性值有JTA、RESOURCE_LOCAL两个--&gt; &lt;persistence-unit name=&quot;query_pu&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; &lt;!-- 指定该API使用hibernate作为实现 --&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;!-- 列出该应用需要访问的所有的Entity类, 也可以用&lt;mapping-file&gt;或&lt;jar-file&gt;元素来定义 --&gt; &lt;class&gt;org.crazyit.app.domain.Course&lt;/class&gt; &lt;class&gt;org.crazyit.app.domain.Enrolment&lt;/class&gt; &lt;class&gt;org.crazyit.app.domain.Student&lt;/class&gt; &lt;!-- properties元素用于为特定JPA实现包配置属性 --&gt; &lt;!-- 下面列举的是Hibernate JPA实现中可以配置的部分属性 --&gt; &lt;properties&gt; &lt;!-- 指定连接数据库的驱动名 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- 指定连接数据库的URL --&gt; &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://10.204.17.116/hibernate?useSSL=true&quot;/&gt; &lt;!-- 指定连接数据库的用户名 --&gt; &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt; &lt;!-- 指定连接数据库的密码 --&gt; &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;123456&quot;/&gt; &lt;!-- 指定连接数据库的方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;/&gt; &lt;!-- 指定连接池里连接的超时时长 --&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot; value=&quot;5000&quot;/&gt; &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot; value=&quot;100&quot;/&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot; value=&quot;3000&quot;/&gt; &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;hibernate.c3p0.validate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;!-- 设置是否格式化SQL语句 --&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;!-- 设置是否根据要求自动建表 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 动态查询由如下三个类完成 CriteriaBuilder:工厂类，可创建Predicate(代表一个查询条件)，Expression(代表表达式)，CriteriaQuery,CriteriaUpdate,CriteriaDelete Root: 代表要查询的根实体 Join: 代表一个关联CriteriaQuery用于将一条select语句分开成不同的方法可以对不同的子句进行动态组合123456789101112131415161718final static EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;query_pu&quot;);// 打开EntityManager和事务EntityManager em = emf.createEntityManager();em.getTransaction().begin();CriteriaBuilder builder = em.getCriteriaBuilder();// 创建CriteriaQuery，传入的类型参数代表该条件查询返回结果集里的元素类型CriteriaQuery&lt;Student&gt; criteria = builder.createQuery(Student.class);// 设置要查询的根实体类Root&lt;Student&gt; root = criteria.from(Student.class);// 下面语句不是必须的，条件查询默认会查询唯一的Root实体criteria.select(root);// 使用builder生成查询条件Predicate pred = builder.greaterThan(root.get(Student_.name), &quot;a&quot;); // ①// 使用CriteriaQuery的where()方法添加查询条件criteria.where(pred);List&lt;Student&gt; list = em.createQuer(criteria).getResultList();]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HQL]]></title>
    <url>%2F2018%2F11%2F22%2FHQL%2F</url>
    <content type="text"><![CDATA[HQL全称Hibernate Query Langeage接近于SQL语句 DML风格批量更新|删除HQL支持批量update和delete,格式如下1update | delete from? &lt;Classname&gt; [where where_conditions] from子句可选，可以不写 from子句只能有一个类名，可为该类名指定别名 不能在批量HQL语句中使用连接，可以在where子句中使用子查询 where子句可选批量操作如下1234567String hqlUpdate = &quot;update User u set name = :newName&quot;;int updateEntities = session.createQuery(hqlUpdate).setParameter(&quot;newName&quot;,&quot;新名字&quot;);.executeUpdate();String hqlUpdate = &quot;delete User&quot;;int deleteEntities = session.createQuery(hqlUpdate).executeUpdate(); 这种语法类似于PreparedStatement的executeUpdate()语法，推荐使用占位符?N(问号加索引)相应的setParameter(“1”,value);也可用‘:’+参数名字赋值如上 HQL查询使用Session的createQuery(hql,Class)创建一个Query对象，Query对象使用setParameter()为HQL语句赋值，最后调用getResultList()返回查询结果12345List&lt;Person&gt; p1 = session.createQuery(&quot;select distinct p from Person p join p.myEvents where title = :eventTitle&quot;,Person.class);.setParameter(&quot;eventTitle&quot;, &quot;普通的事&quot;).getResultList();for(Person p : p1) System.out.println(p.getName()); 关联和连接分为显示连接和隐式连接，隐式连接转化为SQL99的交叉连接（笛卡尔积），显示连接转化为SQL99的inner join、left join、right join等，Hibernate只会对实体的普通组件属性和单个关联实体自动使用隐式连接，对于集合属性只能使用显式连接，显式连接可用with提供额外的连接条件form Person p inner join p.myEvent event with p.id &gt; enevt.id 命名查询将HQL语句从java中提取出来，放到注解中配置，使用@NameQuary(name = “名称”,query = “HQL语句”)如果放在XML注解中&lt;query name=&quot;&quot;&gt; HQL语句&lt;/query&gt;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个Hibernate]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AC%AC%E4%B8%80%E4%B8%AAHibernate%2F</url>
    <content type="text"><![CDATA[Hibernate是javaEE的持久层解决方案，可以管理Java类到数据库的映射，还提供数据查询和获取数据 的方法，Hibernate完成了对象模型和基于SQL的关系模型的映射关系，使得开发者可以完全采用面向对象的方式来开发应用程序，所谓的持久层是指向储存器中储存数据的一组类和组件，是一个相对独立的逻辑层面。 持久化对象(PO)News类12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity@Table(name=&quot;news_inf&quot;)public class News&#123; // 消息类的标识属性 @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 消息标题 private String title; // 消息内容 private String content; // id的setter和getter方法 public void setId(Integer id) &#123; this.id = id; &#125; public Integer getId() &#123; return this.id; &#125; // title的setter和getter方法 public void setTitle(String title) &#123; this.title = title; &#125; public String getTitle() &#123; return this.title; &#125; // content的setter和getter方法 public void setContent(String content) &#123; this.content = content; &#125; public String getContent() &#123; return this.content; &#125;&#125; News本身是一个普通的JavaBean,为他加上持久化注解就变成了持久化对象PO=POJO（普通传统Java对象）+持久化注解 @Entity注解声明该类是个Hibernate持久化类 @Table注解指定该类映射的数据表 @Id指定该类的标识属性 @GeneratedValue(strategy=GenerationType.IDENTITY)用于主键的生成策略Hibernate的XML配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定连接数据库所用的驱动 --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 指定连接数据库的url，其中hibernate是本应用连接的数据库名 --&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost/hibernate?useSSL=true&lt;/property&gt; &lt;!-- 指定连接数据库的用户名 --&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;!-- 指定连接数据库的密码 --&gt; &lt;property name=&quot;connection.password&quot;&gt;32147&lt;/property&gt; &lt;!-- 指定连接池里最大连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt; &lt;!-- 指定连接池里最小连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;1&lt;/property&gt; &lt;!-- 指定连接池里连接的超时时长 --&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;5000&lt;/property&gt; &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/property&gt; &lt;!-- 指定数据库方言 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 根据需要自动创建数据表 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;&lt;!--①--&gt; &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 将SQL脚本进行格式化后再输出 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 罗列所有持久化类的类名 --&gt; &lt;mapping class=&quot;org.crazyit.app.domain.News&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; &lt;!DOCTYPE&gt;一个文档类型标记，它的目的是要告诉通用标记语言解析器，他应该使用什么样的文档类型定义（DTD）来解析文档，Hibernate配置文件的默认文件名为hibernate.cfg.xml，当程序调用Configuration对象的configure()方法时会自动加载该文件，Hibernate推荐使用C3P0数据源，数据源会负责维持一个数据连接池，当程序创建数据源实例时，系统会一次性创建多个数据库连接，并保存在连接池中 完成消息插入的代码12345678910111213141516171819202122232425262728293031public class NewsManager&#123; public static void main(String[] args) throws Exception &#123; // 实例化Configuration Configuration conf = new Configuration() // 不带参数的configure()方法默认加载hibernate.cfg.xml文件 // 如果传入abc.xml作为参数，则不再加载hibernate.cfg.xml，改为加载abc.xml .configure(); // 以Configuration实例创建SessionFactory实例 SessionFactory sf = conf.buildSessionFactory(); // 创建Session Session sess = sf.openSession(); // 开始事务 Transaction tx = sess.beginTransaction(); // 创建消息对象 News n = new News(); // 设置消息标题和消息内容 n.setTitle(&quot;疯狂Java联盟成立了&quot;); n.setContent(&quot;疯狂Java联盟成立了，&quot; + &quot;网站地址http://www.crazyit.org&quot;); // 保存消息 sess.save(n); // 提交事务 tx.commit(); // 关闭Session sess.close(); sf.close(); &#125;&#125; Configuration负责加载Hibernate配置文件 SessionFactory是数据库编译后的内存镜像，通常一个应用对应一个SessionFactory， Session是应用程序和持久储存层之间交互操作和一个单线程对象，所有的持久化对象必须在session管理下才可以进行持久化操作，生存期很短，它底层封装了JDBC连接，他也是Transaction的工厂，Session对象持有必选的一级缓存，在显式执行flush之前所有持久化操作的数据都在缓存中的session对象处 Transaction(事务)代表一次原子操作，它具有数据库事务的概念，所有的持久化操作都应该在事务管理下进行]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitHub新手教程]]></title>
    <url>%2F2018%2F10%2F30%2FGitHub%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[先在GitHub上创建一个库,安装Git Bash软件，第一次使用需要在你的电脑获得一个密钥，在Git Bash中输入1$ ssh-keygen-t rsa-C &quot;your_email@youremail.com&quot; 然后在/Users/pc下找到.ssh下的id_rsa，复制其中的密钥放到你GitHub库中：点击Github项目右上角的下拉菜单setting找到SSH and GPG keys把密钥放上，然后回到Git Bash上输入123$ ssh -T git@github.com$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot; 接下来将库克隆到本地电脑1git clone https://github.com/HananiJia/test.git git clone后面的网址就是创建库成功之后的网址，生成的这个文件夹有一个.git文件把你想要上传的文件放到这个文件夹下，然后定位到这个文件夹下，然后输入123git add test.txtgit commit -m &quot;备注&quot;git push origin master master可以替换为任何分支]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Convention插件与约定支持]]></title>
    <url>%2F2018%2F10%2F23%2FConvention%E6%8F%92%E4%BB%B6%E4%B8%8E%E7%BA%A6%E5%AE%9A%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Struts2引入了Convention来支持零配置，不需要sturts.xml进行配置，而是根据约定来自动配置 Action的搜索和映射约定Convention插件会自动搜索action,actions,sturts,struts2包下所有的java类Convention会把下两种Java当成Action处理 所有实现com.opensymphony.xwork2.Action的Java类 所有类名以Action结尾的Java类映射Action的name时： 如果Action类名包含Action后缀,将后缀去掉，否则不做任何处理 将Action类名的驼峰写法转换成中划线写法例如GetBooks映射为get-books例如将org.crazyit.app.action.user;LoginAction将表单定义为&lt;s:form action=”/user/login”&gt;按约定映射Result默认情况下Convention总会到web应用的WEB-INF/content路径下定位物理资源，定位资源的约定是actionName+resultcode+suffix当找不到对应的视图资源时，Convention会自动试图使用action+suffix作为视图资源例如org.crazyit.app.action.user.LoginAction返回success字符串时，优先考虑login-success.jsp如果找不到该文件，login.jsp也可作为对应视图资源Config Browser插件复制strut2-config-browser-plugin-2.5.14.jar复制到WEB-INF\lib下然后输入地址http://localhost:8080/web项目名/config-browser/actionNames.actionAction链的约定如果希望一个Action处理结束后不是进入视图界面而是进入另一个Action形成Action链只需要遵循下面三个约定 第一个Action返回的逻辑视图字符串没有对应的视图资源 第二个Action与第一个Action处于同一个包下 第二个Action的映射URL为：firstactionName+resultcode如FirstAction返回”second”第二个Action为FirstSecondAction]]></content>
      <categories>
        <category>struts</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个struts2工程]]></title>
    <url>%2F2018%2F10%2F15%2F%E7%AC%AC%E4%B8%80%E4%B8%AAstruts2%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[struts2是一个优秀的MVC框架，减少了耦合增加了可扩展性。 ##添加JAR包将Struts2的lib目录下的JAR包复制到应用的/WEB-INF/lib下 web.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Struts 2的核心Filter拦截所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; struts.xml核心配置文件放在eclipse的src下12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;mess&quot;/&gt; &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot;/&gt; &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt; &lt;!-- 所有的Action定义都应该放在package下 --&gt; &lt;package name=&quot;lee&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot; strict-method-invocation=&quot;false&quot;&gt; &lt;action name=&quot;login&quot; class=&quot;org.crazyit.app.action.LoginAction&quot;&gt; &lt;result name=&quot;error&quot;&gt;/WEB-INF/content/error.jsp&lt;/result&gt; &lt;result name=&quot;success&quot;&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;package name=&quot;crazyit&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;*&quot;&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; JSP页面1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;&lt;s:text name=&quot;loginPage&quot;/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;s:form action=&quot;login&quot;&gt; &lt;s:textfield name=&quot;username&quot; key=&quot;user&quot;/&gt; &lt;s:textfield name=&quot;password&quot; key=&quot;pass&quot;/&gt; &lt;s:submit key=&quot;login&quot;/&gt;&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; Action类123456789101112131415161718192021222324252627282930package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;public class LoginAction &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String execute () throws Exception &#123; if(getUsername().equals(&quot;crazyit.org&quot;)&amp;&amp; getPassword().equals(&quot;leegang&quot;)) &#123; ActionContext.getContext().getSession().put(&quot;user&quot;, getUsername()); return &quot;success&quot;; &#125; return &quot;error&quot;; &#125;&#125; 国际化资源mess_zh_CN.propeties放在scr下12345678loginPage=登录页面errorPage=错误界面succPage=成功界面failTip=对不起，您不能登录！succTip=欢迎user=用户名pass=密码login=登录]]></content>
      <categories>
        <category>struts</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于eclipse的web工程标注无效]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%85%B3%E4%BA%8Eeclipse%E7%9A%84web%E5%B7%A5%E7%A8%8B%E6%A0%87%E6%B3%A8%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[在eclipse里开发web项目时在使用servlet3.0的标注时我遇到了注释无效的问题，解决办法是在部署完项目到webapps后，右键项目的Export选择War File导入到tomcat的webapps下就能使用了]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Eclipse添加用户库]]></title>
    <url>%2F2018%2F10%2F10%2FEclipse%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%BA%93%2F</url>
    <content type="text"><![CDATA[添加用户库是为了方便管理多个JAR文件，例如在添加Hibnate和Struts时会很方便右键项目节点，单击”Build Path” -&gt; “Configure Build Path…”,在出现的对话框中选中”User Library”,并单击”next”,在右边选中”User Library”,如需要新增用户库就单击”New”,选中要编辑的用户库的名字，然后单击”Add External JARS”]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql正则表达式]]></title>
    <url>%2F2018%2F10%2F08%2Fmysql%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[连接mysql:mysql -h+ip -uroot -p+密码Mysql仅支持正则表达式的一个子集，关键字为REGEXP类似于Mysql的like,不同在于like仅当字符完全匹配才返回数据而REGEXP如果列值出现匹配文本就返回数据 ##OR匹配用’|’,匹配多个字符时可用[123]为[1|2|3]的缩写[^123]为除123以外 ##匹配范围[1-9],[a-z]匹配是默认不区分大小写的，可使用BINATY关键字如where name REGEXP BINARY ‘Li ‘ 匹配特殊字符对特殊字符转义用\为前引12345\\f 换页\\n 换行\\r 回车\\t 制表\\v 纵向制表 匹配字符类12345678[:alnum:] 任意字母和数字[:alpha:] 任意字母[:blank:] 空格和制表[:digit:] 任意数字[:lower:] 任意小写字母[:upper:] 任意大写字母[:print:] 任意可打印字符[:space:] 任意空白字符 匹配多个实例123456* 多个匹配+ 1个或多个匹配？ 0个或1个匹配&#123;n&#125; 指定数目的匹配&#123;n,&#125; 不少于指定数目的匹配&#123;n,m&#125; 匹配数目的范围 例如where name REGEXP ‘\([0-9] sticks?\)’s后的?使s变得可选可匹配stricks或stick ##定位符1234^ 文本的开始$ 文本的结束[[:&lt;:]] 词的开始[[:&gt;:]] 词的结束]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F09%2F26%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[JAVA反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法：对于任意一个类都能够调用它的任意一个方法和属性； 获取Class对象的三种方式Student stu = new Student();//产生一个Student对象，一个Class对象1.Class stuClass = stu.getClass();2.Class stuClass = Student.class;3.Class stuClass = Class.forname(包名.类名);在运行期间一个类只能产生一个Class对象 通过反射获取构造方法并使用student类1234567891011121314151617181920212223package suanfa;public class Student &#123; Student(String str)&#123; System.out.println(&quot;默认的构造方法s=&quot;+str); &#125; public Student() &#123; System.out.println(&quot;调用了公有,无参数构造方法执行&quot;); &#125; public Student(char name) &#123; System.out.println(&quot;姓名:&quot;+name); &#125; public Student(String name, int age) &#123; System.out.println(&quot;姓名&quot;+name+&quot;年龄&quot;+age); &#125; protected Student(boolean n) &#123; System.out.println(&quot;受保护的构造方法n=&quot;+n); &#125; private Student(int age) &#123; System.out.println(&quot;私有化的构造方法年龄:&quot;+age); &#125;&#125; 12345678910//加载Class对象：Class clazz = Class.forName(&quot;suanfa.Student&quot;);//获取所有公有构造方法Constructor[] conArray = clazz.getConstructors();//获取所有的构造方法conArray = clazz.getDeclaredConstructors();//获取公有，无参的构造方法Constructor con = clazz.getConstructor(null);con = clazz.getDeclaredConstructor(char.class);con.newInstance(&apos;男&apos;);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F09%2F26%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绿色计算大赛文件查看器]]></title>
    <url>%2F2018%2F09%2F25%2F%E7%BB%BF%E8%89%B2%E8%AE%A1%E7%AE%97%E5%A4%A7%E8%B5%9B%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[编写代码实现对给定文件夹目录结构的展示，如果文件的英文夹数则在其名字之前加上+–若是文件则加上–，上级目录与下级目录，文件下级用两个空格作为间隔 123456789101112131415161718192021import java.io.File;public class Task &#123; /********** BEGIN **********/ public void showDirStructure(File file) &#123; System.out.println(&quot;+--&quot; + file.getName()); showDirTree(file,&quot; &quot;); &#125; public static void showDirTree(File dir,String interval)&#123; File[] files = dir.listFiles(); interval += &quot; &quot;; for (File file : files) &#123; if(!file.isDirectory())&#123; System.out.println(interval + &quot;--&quot; + file.getName()); &#125;else&#123; System.out.println(interval + &quot;+--&quot; + file.getName()); showDirTree(file,interval + &quot; &quot;); &#125; &#125; &#125; /********** END **********/&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode链表中倒数第k个节点]]></title>
    <url>%2F2018%2F09%2F25%2FLeetcode%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[输入一个链表，输出该链表中倒数第k个节点 分析：采用单循环用两个指针,一个节点node1先开始跑，指针node1跑到k-1个节点后，另一个节点node2开始跑,当node1跑到终点node2就是倒数第k个节点1234567891011121314151617181920212223242526272829public class ListNode&#123; int val; ListNode next; ListNode(int x) &#123;val = x; &#125;&#125;public class Solution &#123; public ListNode FindKthToTail(ListNode head, int k) &#123; //如果链表为空或k&lt;=0 if(head == null || k &lt;= 0) &#123; return null; &#125; ListNode node1 = head , node2 = head; int count = 0; int index = k; while (node1 != null) &#123; node1 = node1.next; count ++; if (k &lt; 1 &amp;&amp; node1 != null) &#123; node2 = node2.next; &#125; k--; &#125; if(count &lt; index) return null; return node2; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode反转链表]]></title>
    <url>%2F2018%2F09%2F24%2FLeetcode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[输入一个链表，反转后输出所有元素123456789101112131415161718192021public class ListNode&#123; int val; ListNode next; ListNode(int x) &#123;val = x; &#125;&#125;public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode next = null; ListNode pre = null; while(head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode链表两数相加]]></title>
    <url>%2F2018%2F09%2F23%2FLeetcode%E9%93%BE%E8%A1%A8%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目：给定两个非空链表来表示两个非负整数，位数按照逆序方式储存，它们的每个节点只储存单个数字，将两数相加返回一个新的链表示例：(2-&gt;4-&gt;3)+(5-&gt;6-&gt;4)(7-&gt;0-&gt;8)123456789101112131415161718192021222324252627282930public class ListNode&#123; int val; ListNode next; ListNode(int x) &#123;val = x; &#125;&#125;public class Solution &#123; public ListNode addTwoNumbers(ListNode l1,ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1 , q = l2 , curr = dummyHead; //carry表示进位数 int carry = 0; while(p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum%10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[直接插入排序:将一条记录插入到已排好的有序表中，得到一个新的有序表123456789101112131415int a[]=&#123;98,76,109,34,67,190,80,12,14,89,1&#125;;int k=sizeof(a)/sizeof(a[0]);int j;for(int i=1;i&lt;k;i++)//循环从第2个元素开始&#123; if(a[i]&lt;a[i-1]) &#123; int temp=a[i]; for(j=i-1;j&gt;=0 &amp;&amp; a[j]&gt;temp;j--) &#123; a[j+1]=a[j]; &#125; a[j+1]=temp;//此处就是a[j+1]=temp; &#125;&#125; 冒泡排序:只比较相邻数字，下一次循环比较次数减一1234567891011121314void bubble_sort(int a[], int n)&#123; int i, j, temp; for (j = 0; j &lt; n - 1; j++) for (i = 0; i &lt; n - 1 - j; i++) &#123; if(a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; &#125; &#125;&#125; 简单选择排序:找出每趟最小的数与第i个交换，n-1趟后完成排序123456789101112131415int a[10],i,j,k,t;for(i=0;i&lt;10;i++)&#123; t=i; for(j=i+1;j&lt;10;j++) &#123; if(a[t]&gt;a[j]) &#123; t=j &#125; &#125; int temp = a[i]; a[i]=a[t]; a[t]=temp;&#125; 归并排序：将已有序的子序列合并，得到完全有序序列这个代码就有点些复杂了，首先把一个序列不断划分子序列1234567891011void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)&#123; int midIndex; if(startIndex &lt; endIndex) &#123; midIndex = startIndex + (endIndex-startIndex) / 2;//避免溢出int MergeSort(sourceArr, tempArr, startIndex, midIndex); MergeSort(sourceArr, tempArr, midIndex+1, endIndex); Merge(sourceArr, tempArr, startIndex, midIndex, endIndex); &#125;&#125; 然后就是如何合并子序列,temp只是一个用来暂时存放数据的数组例如：5678 1234合并一个指针i在5一个指针j在1还有个临时指针k直到前子序列和后子序列有一个已经合并完成，将另一个直接放到temp里1234567891011121314151617void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)&#123; int i = startIndex, j=midIndex+1, k = startIndex; while(i!=midIndex+1 &amp;&amp; j!=endIndex+1) &#123; if(sourceArr[i] &gt; sourceArr[j]) tempArr[k++] = sourceArr[j++]; else tempArr[k++] = sourceArr[i++]; &#125; while(i != midIndex+1) tempArr[k++] = sourceArr[i++]; while(j != endIndex+1) tempArr[k++] = sourceArr[j++]; for(i=startIndex; i&lt;=endIndex; i++) sourceArr[i] = tempArr[i];&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于XML Schema的简化配置]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%9F%BA%E4%BA%8EXML-Schema%E7%9A%84%E7%AE%80%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[从Spring2.0以来Spring允许使用XML Schema的配置方式来简化Spring配置文件，这种方式更加简洁,好好享用这份蜜糖 使用p:命名空间简化配置设置注入12&lt;property name=&quot;axe&quot; ref=&quot;stoneAxe&quot;/&gt;&lt;property name=&quot;age&quot; value=&quot;29&quot;/&gt; 使用p:命名空间：首先导入XML Schema里的p:命名空间12xmlns:p=&quot;http://www.springframework.org/&lt;bean id= class= p:age=&quot;29&quot; p:axe-ref=&quot;stoneAxe&quot;/&gt; 使用c：命名空间简化构造注入123456&lt;constructor-arg value=&quot;29&quot;/&gt;&lt;constructor-arg ref=&quot;steelAxe&quot;/&gt;&lt;constructor-arg index=&quot;2&quot; value=&quot;hello&quot;/&gt;使用c:xmlns:c=&quot;http://www.springframework.org/&lt;bean id= class= c:age=20 c:axe-ref=&quot;steelAxe&quot; c:_0=&quot;29&quot;/&gt; 使用util:命名空间简化高级依赖关系配置获取其他Bean的属性值1234567&lt;bean id= class=&gt;&lt;!-- 获取id=person的getson()方法 --&gt;&lt;property name=&quot;targetBeanName&quot; value=&quot;person&quot;/&gt;&lt;property name=&quot;propertyPath&quot; value=&quot;son&quot;/&gt;&lt;!-- 简化后 --&gt;&lt;util:property-path id= path=&quot;person.son&quot;/&gt;&lt;/bean&gt; 注入其他bean中1234567&lt;property name=&quot;age&quot;&gt; &lt;bean id=&quot;person.son.age&quot; class= &quot;org.springframework.beans.factory.xonfig.PropertyPathFactoryBean&quot;/&gt;&lt;/property&gt;&lt;property name=&quot;age&quot;&gt; &lt;util:property-path path=&quot;person.son.age&quot;/&gt;&lt;/property&gt; 获取Field值123456789&lt;property name=&quot;tagetClass&quot; value=&quot;java.sql.Connection&quot;/&gt;&lt;property name=&quot;tagetField&quot; value=&quot;TRANSACTION_SERIALIZABLE&quot;&gt;使用util:获取Field值xmls:util=&quot;http://www.springframework.org/schema/util&quot;http://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util&quot;&lt;util:constant id=&quot;chan.age&quot; static-field=&quot;java.sql.Connection.TRANSACTION_SERIALIZABLE&quot;/&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或2级台阶，求一共有多少种走法，经典的动态规划问题动态规划当中包含三个重要的概念：最优子结构，边界，状态转移公式对于这题最优子结构为F(10)=F(9)+F(8),边界为F(1)和F(2),状态转移方程为F(N)=F(N-1)+F(N-2),由此得递归函数123456int getClimbingWays(int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; if(n==2) return 2; return getClimbingWays(n-1) + getClimbingWays(n-2)&#125; 接下来对该函数进行时间优化,用map来存储信息，也就是备忘录算法123456789101112int getClimbingWays(Map&lt;Integer,Integer&gt; map,int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; if(n==2) return 2; if(map.containsKey(n))&#123; return map.get(n); &#125;else&#123; int value = getClimbingWays(map,n-1)+getClimbingWays(map,n-2); map.put(n,value); return value;&#125;&#125; 上述算法都是自顶向下计算，这次换成自底向上计算，也就是动态规划算法1234567891011121314int getClimbingWays(int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; if(n==2) return 2; int a = 1; int b = 2; int temp = 0; for(int i=3;i&lt;=n;i++)&#123; temp = a+b; a = b; b = temp; &#125; return temp;&#125; 时间复杂度为o(n)空间复杂度为o(1)实现了最优化，这就是动态规划题目二：国王和金矿10个工人，5个金矿分别为500金/5人，200金/3人，300金/4人，350/3人，400金/5人分析：最优子结构有两个一个是4金矿10个人，一个是4金矿10-3人时，边界是只有一座金矿和给定的工人不够第一座金矿，设金矿数量为n,工人数为w黄金量为g[],金矿的用工量为p[]12345678910111213141516int getMostGold(int n,int w,int[] g ,int []p)&#123; int[] preResults = new int[p.length]; int[] results = new int[p.length]; for(int i=0;i&lt;=n;i++)&#123; if(i&lt;p[0]) preResults[i] = 0; else preResults[i] = g[0]; &#125; for(int i=0;i&lt;=w;i++)&#123; for(int j=0;j&lt;=w;j++)&#123; if(j&lt;p[i]) results[j] = preResults[j]; else results[j] = Math.max(reResults[j],preResults[j-p[i]+g[i]]); &#125; preResults = results; &#125; return results[n];&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lintcode:尾部的零]]></title>
    <url>%2F2018%2F09%2F17%2Flintcode%E5%B0%BE%E9%83%A8%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[题目：计算出n阶乘中尾部零的个数1、2、3、4、5、6、7、8、9、10、11…、5…、10…、15…、20…、25…这些数中每5个产生一个0，化简成5k…、25…50…75…100…125…将其中k=5,10,15,20又能产生一个0，由此递归得123456while(n)&#123; num += n / 5; n = n / 5;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 解题关键在于如何解决25的倍数这些数，细心观察化简为5k后规律是一致的]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lintcode:a+b]]></title>
    <url>%2F2018%2F09%2F16%2Flintcode-a-b%2F</url>
    <content type="text"><![CDATA[题目：不用+等运算符运算实现加法思路很明确就是用二进制来运算,1.and运算&amp;相同位的两个数字为一则为1，如有一个不为1则为02.or运算|相同位只要有一个1即为13.xor异或运算^相同位不同则为1，相同为01的二进制….00012的二进制….00103的二进制….00114的二进制….0100由此我们可以推测出不进位时a+b=a|b,需要进位时先计算a^b，再计算应该进位的值(a&amp;b)&lt;&lt;1,递归调用12345int aplusb(int a, int b) &#123; if((a&amp;b) == 0) return a|b; return aplusb(a^b,(a&amp;b)&lt;&lt;1);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo命令]]></title>
    <url>%2F2018%2F09%2F16%2Fhexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用网站集]]></title>
    <url>%2F2018%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 大连民族大学 tags:This article is just to test my blog,welcome高清壁纸网站贴图库图片外联绿色计算机大赛在线绘图csdnlintCode刷题leetcode刷题]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
