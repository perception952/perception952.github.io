<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringIoC]]></title>
    <url>%2F2018%2F12%2F08%2FSpringIoC%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制反转(Inversion of Control)也称依赖注入(Dependcy Injection)是Spring容器的核心功能，Spring容器作为一个超级工厂，负责创建所有java对象，这些对象成为Bean,Spring使用依赖注入的方式来管理Bean之间的依赖关系，其核心思想是工厂模式当某个java对象需要调用另一个对象时在传统模式下 原始做法：调用者主动创建被依赖对象，然后再调用被依赖对象的方法 简单工厂：调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始做法会导致调用者与被依赖对象的硬编码耦合，非常不利于项目的维护，升级，对于简单工厂模式，调用者面向被依赖对象的接口编程，将被依赖对象的创建交给工厂，调用者通过工厂来获得被依赖组件，简单工厂避免了类层次的硬编码耦合，只需与被依赖对象的接口耦合，但会带来调用组件与被依赖对象工厂的耦合使用Spring框架后，调用者无需主动获取被依赖对象，这要被动接受Spring容器为调用者的成员变量赋值即可，即调用者获取被依赖对象的方式由原来的主动获取变成了被动接受，也就是所谓的控制反转，无论是调用者还是被依赖对象都应该为之定义接口，程序应该面向他们的接口，而不是面向实现类编程，这样以便程序后期的升级、维护下面用工厂模式实现类似SpringIOC的实例 配置文件1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;&lt;beans&gt; &lt;bean id=&quot;computer&quot; class=&quot;lee.Computer&quot;&gt; &lt;!-- 为name注入基本类型的值 --&gt; &lt;property name=&quot;name&quot; value=&quot;孙悟空的电脑&quot;/&gt; &lt;!-- 为out注入工厂中其他对象 --&gt; &lt;property name=&quot;out&quot; ref=&quot;betterPrinter&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置两个Bean实例 --&gt; &lt;bean id=&quot;printer&quot; class=&quot;lee.Printer&quot;/&gt; &lt;bean id=&quot;betterPrinter&quot; class=&quot;lee.BetterPrinter&quot;/&gt; &lt;!-- 配置一个prototype行为的Bean实例 --&gt; &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;/&gt;&lt;/beans&gt; Application接口123456public interface ApplicationContext&#123; // 获取指定Bean实例的方法 Object getBean(String name) throws Exception;&#125; 工厂类使用Dom4j来解析XML配置文件，并根据配置文件来创建工厂中的Bean实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public class CrazyitXmlApplicationContext implements ApplicationContext&#123; // 保存容器中所有单例模式的Bean实例 private Map&lt;String , Object&gt; objPool = Collections.synchronizedMap(new HashMap&lt;String , Object&gt;()); // 保存配置文件对应的Document对象 private Document doc; // 保存配置文件里的根元素 private Element root; public CrazyitXmlApplicationContext(String filePath) throws Exception &#123; SAXReader reader = new SAXReader(); doc = reader.read(new File(filePath)); root = doc.getRootElement(); initPool(); initProp(); &#125; public Object getBean(String name) throws Exception &#123; Object target = objPool.get(name); // 对于singleton Bean，容器已经初始化了所有Bean实例，直接返回即可 if (target.getClass() != String.class) &#123; return target; &#125; else &#123; String clazz = (String)target; // 对于prototype对象并未注入属性值 return Class.forName(clazz).getConstructor().newInstance(); &#125; &#125; // 初始化容器中所有singleton Bean private void initPool() throws Exception &#123; // 遍历配置文件里的每个&lt;bean.../&gt;元素 for (Object obj : root.elements()) &#123; Element beanEle = (Element)obj; // 取得&lt;bean.../&gt;元素的id属性 String beanId = beanEle.attributeValue(&quot;id&quot;); // 取得&lt;bean.../&gt;元素的class属性 String beanClazz = beanEle.attributeValue(&quot;class&quot;); // 取得&lt;bean.../&gt;元素的scope属性 String beanScope = beanEle.attributeValue(&quot;scope&quot;); // 如果&lt;bean.../&gt;元素的scope属性不存在，或为singleton if (beanScope == null || beanScope.equals(&quot;singleton&quot;)) &#123; // 以默认构造器创建Bean实例，并将其放入objPool中 objPool.put(beanId , Class.forName(beanClazz) .getConstructor().newInstance()); &#125; else &#123; // 对于非singlton Bean，存放该Bean实现类的类名。 objPool.put(beanId , beanClazz); &#125; &#125; &#125; // 初始化容器中singleton Bean的属性 private void initProp() throws Exception &#123; // 遍历配置文件里的每个&lt;bean.../&gt;元素 for (Object obj : root.elements()) &#123; Element beanEle = (Element)obj; // 取得&lt;bean.../&gt;元素的id属性 String beanId = beanEle.attributeValue(&quot;id&quot;); // 取得&lt;bean.../&gt;元素的scope属性 String beanScope = beanEle.attributeValue(&quot;scope&quot;); // 如果&lt;bean.../&gt;元素的scope属性不存在，或为singleton if (beanScope == null || beanScope.equals(&quot;singleton&quot;)) &#123; // 取出objPool的指定的Bean实例 Object bean = objPool.get(beanId); // 遍历&lt;bean.../&gt;元素的每个&lt;property.../&gt;子元素 for (Object prop : beanEle.elements()) &#123; Element propEle = (Element)prop; // 取得&lt;property.../&gt;元素的name属性 String propName = propEle.attributeValue(&quot;name&quot;); // 取得&lt;property.../&gt;元素的value属性 String propValue = propEle.attributeValue(&quot;value&quot;); // 取得&lt;property.../&gt;元素的ref属性 String propRef = propEle.attributeValue(&quot;ref&quot;); // 将属性名的首字母大写 String propNameCamelize = propName.substring(0 , 1) .toUpperCase() + propName.substring(1 , propName.length()); // 如果&lt;property.../&gt;元素的value属性值存在 if (propValue != null &amp;&amp; propValue.length() &gt; 0) &#123; // 获取设值注入所需的setter方法 Method setter = bean.getClass().getMethod( &quot;set&quot; + propNameCamelize , String.class); // 执行setter注入 setter.invoke(bean , propValue); &#125; if (propRef != null &amp;&amp; propRef.length() &gt; 0) &#123; // 取得需要被依赖注入的Bean实例 Object target = objPool.get(propRef); //objPool池中不存在指定Bean实例 if (target == null) &#123; // 此处还应处理Singleton Bean依赖prototype Bean的情形 &#125; // 定义设值注入所需的setter方法 Method setter = null; // 遍历target对象所所实现的所有接口 for (Class superInterface : target.getClass().getInterfaces()) &#123; try &#123; // 获取设值注入所需的setter方法 setter = bean.getClass().getMethod( &quot;set&quot; + propNameCamelize , superInterface); // 如果成功取得该接口对应的方法，直接跳出循环 break; &#125; catch (NoSuchMethodException ex) &#123; // 如果没有找到对应的setter方法，继续下次循环 continue; &#125; &#125; // 如果setter方法依然为null， // 则直接取得target实现类对应的setter方法 if (setter == null) &#123; setter = bean.getClass().getMethod( &quot;set&quot; + propNameCamelize , target.getClass()); &#125; // 执行setter注入 setter.invoke(bean , target); &#125; &#125; &#125; &#125; &#125;&#125; Output接口12345678public interface Output&#123; // 接口里定义的属性只能是常量 int MAX_CACHE_LINE = 50; // 接口里定义的只能是public的抽象实例方法 void out(); void getData(String msg);&#125; Output实现类12345678910111213141516171819202122232425262728public class Printer implements Output&#123; private String[] printData = new String[MAX_CACHE_LINE]; // 用以记录当前需打印的作业数 private int dataNum = 0; public void out() &#123; // 只要还有作业，继续打印 while(dataNum &gt; 0) &#123; System.out.println(&quot;打印机打印：&quot; + printData[0]); // 把作业队列整体前移一位，并将剩下的作业数减1 System.arraycopy(printData , 1, printData, 0, --dataNum); &#125; &#125; public void getData(String msg) &#123; if (dataNum &gt;= MAX_CACHE_LINE) &#123; System.out.println(&quot;输出队列已满，添加失败&quot;); &#125; else &#123; // 把打印数据添加到队列里，已保存数据的数量加1。 printData[dataNum++] = msg; &#125; &#125;&#125; Output实现类12345678910111213141516171819202122232425262728public class BetterPrinter implements Output&#123; private String[] printData = new String[MAX_CACHE_LINE * 2]; // 用以记录当前需打印的作业数 private int dataNum = 0; public void out() &#123; // 只要还有作业，继续打印 while(dataNum &gt; 0) &#123; System.out.println(&quot;高速打印机正在打印：&quot; + printData[0]); // 把作业队列整体前移一位，并将剩下的作业数减1 System.arraycopy(printData , 1, printData, 0, --dataNum); &#125; &#125; public void getData(String msg) &#123; if (dataNum &gt;= MAX_CACHE_LINE * 2) &#123; System.out.println(&quot;输出队列已满，添加失败&quot;); &#125; else &#123; // 把打印数据添加到队列里，已保存数据的数量加1。 printData[dataNum++] = msg; &#125; &#125;&#125; Computer类1234567891011121314151617181920212223242526272829public class Computer&#123; private Output out; private String name; public Computer()&#123;&#125; // out的setter和getter方法 public void setOut(Output out) &#123; this.out = out; &#125; // name的setter和getter方法 public void setName(String name) &#123; this.name = name; &#125; // 定义一个模拟获取字符串输入的方法 public void keyIn(String msg) &#123; out.getData(msg); &#125; // 定义一个模拟打印的方法 public void print() &#123; System.out.println(name + &quot;开始打印...&quot;); out.out(); &#125;&#125; 测试类12345678910111213141516public class IoCTest&#123; public static void main(String[] args) throws Exception &#123; // 创建IoC容器 ApplicationContext ctx = new CrazyitXmlApplicationContext(&quot;beans.xml&quot;); // 从IoC容器中取出computer Bean Computer c = (Computer)ctx.getBean(&quot;computer&quot;); // 测试Computer对象 c.keyIn(&quot;轻量级Java EE企业应用实战&quot;); c.keyIn(&quot;疯狂Java讲义&quot;); c.print(); System.out.println(ctx.getBean(&quot;now&quot;)); &#125;&#125; 源码下载]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分，这种思路就叫分冶法，平均时间复杂度是O（nlogn） 基准元素的选择：英文pivot(中心点)，用于分冶过程中以此为中心，把其他元素移动到基准元素的左右两边，基准元素通常选择数列的第一个元素，但在一个原本逆序期望排成顺序数列的情况下，每一轮仅仅确定了基准元素的位置，这也是快排的最坏情况这时的时间复杂度为O(n^2). 元素的移动确定了基准元素后，要做的就是元素移动了，把比基准元素大的移动到基准元素一边，小于基准元素的移动到另一边具体实现有两种方法 挖坑法首先选定基准元素pivot并记住这个位置index,这个位置相当于一个坑，并且设置两个指针left和right指向数列左右两端，接下来总从right指针开始，和基准元素作比较，如果比privot大则right指针向左移动，如果比pivot小则把right所指向的元素填入坑中，这时right指针所在的位置就变成了新的坑，同时left向右移动一位，接下来切换到left指针进行比较，思路不变，left和right重合时把pivot放到index的位置，一轮交换结束123456789101112131415161718192021222324252627282930313233343536373839public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; if(startIndex &gt;= endIndex) &#123; return; &#125; int pivotIndex = partition(arr, startIndex, endIndex); quickSort(arr, startIndex, pivotIndex); quickSort(arr, pivotIndex + 1,endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; //第一个元素当基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; //坑的位置 int index = startIndex; while(right &gt;= left) &#123; while(right &gt;= left) &#123; if(arr[right] &lt; pivot) &#123; arr[left] = arr[right]; index = right; left++; break; &#125; right--; &#125; while(right &gt;= left) &#123; if(arr[left] &gt; pivot) &#123; arr[right] = arr[left]; index = left; right--; break; &#125; left++; &#125; &#125; arr[index] = pivot; return index; &#125; 指针法同样选择基准元素和left、right指针，从right指针开始，把所指元素和基准元素作比较，如果大于等于pivot则向左移动，如果小于pivot则right停止移动，切换到left指针，思路不变，小于基准元素就停下，这时让right和left指向的元素进行交换，当left和right重合时让pivot和重合点元素进行交换，一轮交换结束，指针法元素的交换次数更少12345678910111213141516171819202122232425262728293031public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; if(startIndex &gt;= endIndex) &#123; return; &#125; int pivotIndex = partition(arr, startIndex, endIndex); quickSort(arr, startIndex, pivotIndex); quickSort(arr, pivotIndex + 1,endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; //第一个元素为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while(left != right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right --; &#125; while(left &gt; right &amp;&amp; arr[left] &lt; pivot) &#123; left ++; &#125; if(left &lt; right) &#123; int p = arr[left]; arr[left] = arr[right]; arr[right] = p; &#125; &#125; int p = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = p; return left; &#125; 非递归实现代码中一层一层的方法调用本身就是一个函数栈，在栈中储存每一次方法调用的参数,每次进入一个新方法，就相当于入栈，每次有方法返回就相当于出栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = new Stack&lt;Map&lt;String, Integer&gt;&gt;(); Map&lt;String, Integer&gt; rootParam = new HashMap&lt;String, Integer&gt;(); rootParam.put(&quot;startIndex&quot;, startIndex); rootParam.put(&quot;endIndex&quot;, startIndex); quickSortStack.push(rootParam); while(!quickSortStack.isEmpty()) &#123; Map&lt;String, Integer&gt; param = quickSortStack.pop(); int pivotIndex = partition(arr, param.get(&quot;startIndex&quot;), param.get(&quot;endIndex&quot;)); if(param.get(&quot;startIndex&quot;) &lt; param.get(&quot;endIndex&quot;)) &#123; Map&lt;String, Integer&gt; leftParam = new HashMap&lt;String, Integer&gt;(); leftParam.put(&quot;startIndex&quot;, param.get(&quot;startIndex&quot;)); leftParam.put(&quot;endIndex&quot;, param.get(&quot;endIndex&quot;)); quickSortStack.push(leftParam); &#125; if(pivotIndex + 1 &lt; param.get(&quot;endIndex&quot;)) &#123; Map&lt;String, Integer&gt; rightParam = new HashMap&lt;String, Integer&gt;(); rightParam.put(&quot;startIndex&quot;, startIndex); rightParam.put(&quot;endIndex&quot;, endIndex); quickSortStack.push(rightParam); &#125; &#125;&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; //第一个元素为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while(left != right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right --; &#125; while(left &gt; right &amp;&amp; arr[left] &lt; pivot) &#123; left ++; &#125; if(left &lt; right) &#123; int p = arr[left]; arr[left] = arr[right]; arr[right] = p; &#125; &#125; int p = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = p; return left; &#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程下的单例模式]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式所要实现的目标非常简单，保持一个类有且仅有一个实例，严格来说所谓的“一个类有且仅有一个实例”隐含着一个前提–这个类是一个Java虚拟机实例中的一个Class Loader所加载的类。这是考虑到了Java虚拟机的Class Loader机制：同一个类可以被多个Class Loader加载，这些Class Loader各自创建这个类的实例，因此如果有多个Class Loader加载同一个类，那么所谓的单例就无法满足，被创建的实例数就等于加载这个类的Class Loader数如果单例初始值是null，还未构建，则构建单例对象并返回，这是懒汉模式，如果单例对象一开始就被主动构建不需要判空操作，这是饿汉模式，出于性能的考虑，不少单例模式的实现会采用延迟加载，仅在需要用到相应实例的时候才创建实例， 单线程版单例1234567891011121314public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; //什么也不做 &#125; public static Singleton getSingleton() &#123; if(null == instance) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 加锁版单例最简单加锁12345678public static Singleton getSingleton() &#123; synchronized (Singleton.class) &#123; if(null == instance) &#123; instance = new Singleton(); &#125; &#125; return instance;&#125; 这意味着每次执行线程都要申请锁，为避免锁开销，设计出双重检查锁定 双重检查锁定12345678910public static Singleton getSingleton() &#123; if(null == instance) &#123; //1 synchronized (Singleton.class) &#123; if(null == instance) &#123; //2 instance = new Singleton(); //3 &#125; &#125; &#125; return instance;&#125; 看似既避免了锁开销又保障了线程安全，实则暗藏危机，因为还有重排序的因素，操作3可划分成3个子操作 objRef = allocate(Singleton.class)//分配对象需要的储存空间 incokeConstructor(objRef)//初始化objRef引用的对象 instance = objRef;//将对象引用写入共享变量重排序后可能顺序为132,即变量instance的值不是null,但该变量引用的对象中某些实例变量的值仍是默认值而不是构造函数里的初始值，也就是线程在执行操作1时发现instance不是null，但是该变量未初始化完毕，这就可能导致程序出错！只要把instace参数用volatile修饰即可基于静态内部类12345678910111213141516public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; //什么也不做 &#125; private static class InstanceHolder &#123; final static Singleton INSTANCE = new Singleton(); &#125; public static Singleton getSingleton() &#123; return InstanceHolder.INSTANCE; &#125;&#125; 从外部无法访问静态内部类，只有调用getInstace方法才能得到单例对象，INSTANCE对象初始化时机并不是类被加载的时候，而是调用getInstance时因此利用classloader加载机制来实现懒加载 基于枚举的单例枚举性单例可以防止利用反射来重复构建对象1234567反射//获得构造器Constructor&lt;T&gt; con = Singleton.class.getDeclaredConstructors();//设置为可访问con.setAccessible(true);Singleton singleton1 = (Singleton)con.newInstance();Singleton singleton2 = (Singleton)con.newInstance(); JVM会阻止反射获取枚举类的私有构造方法1234public enum Singleton &#123; INSTANCE;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring的AOP]]></title>
    <url>%2F2018%2F12%2F03%2FSpring%E7%9A%84AOP%2F</url>
    <content type="text"><![CDATA[Aspect Orient Progeamming面向切面编程用于处理系统中分布于各个模块的交叉关注点的问题，在javaEE中处理一些具有横切性质的系统服务，如事务管理，安全检查，缓存 AspectJAspectJ是基于java的AOP框架，是java领域最流行的AOP框架,Spring也引入了对AspectJ的支持]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程锁]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%94%81%2F</url>
    <content type="text"><![CDATA[线程安全问题的产生是因为多个线程并发访问共享数据，于是很容易想到一种保障线程安全的方法，将多个线程对共享数据的并发访问转换为串行访问，锁就是利用这种思路以保障线程安全的同步机制，一个锁一次只能被一个线程持有，也称排他锁，按照java虚拟机对锁的实现方式的划分，包括内部锁和显示锁 可重入性：描述了这样一个问题一个线程在其持有一个锁的时候能否再次申请该锁，如果还能申请成功那么我们就称该锁是可重入的123456789Void methodA()&#123; acquireLock(lock); //申请锁 methodB(); releaseLock(lock);//释放锁&#125;void methodB()&#123; acquireLock(lock);//申请锁 releaseLock(lock);//释放锁&#125; 方法A使用了锁lock,该锁引导的临界区（访问公共资源的程序段）又调用了另外一个方法B,B中也申请了lock，那么问题就产生了，A持有锁的时候调用了B，B又去申请锁，而锁此时正被当前线程持有未被释放，那么B能否申请成功呢，可重入性就是描述了这样一个问题，可重入锁包含一个计数属性，申请锁时判断当前线程是否是已获得锁的线程，是计数+1，该线程获得了N次锁，则需要释放N次才能成功锁泄露：一个线程获得某个锁后由于程序错误使该锁一直无法被释放，而导致其他线程一直无法获得该锁的现象，其危害性在于可重入锁的隐蔽性，可重入锁获得该线程后不释放也不阻碍其后续再次获得该锁（可重入锁本身保证的），导致其他线程永远无法获得锁 内部锁：synchronized关键字（可重入）Java平台的任何一个对象都有唯一一个与之相连的锁，这种锁被称为内部锁，通过synchronized关键字实现，可以用来修饰方法以及代码块1234567Public synchronized add()&#123; Sequence ++;&#125;或Synchronized(锁句柄)&#123; 临界区&#125; 锁句柄是一个对象的引用，锁句柄对应的内部锁被称为相应同步快的引导锁，synchronized修饰的代码块叫同步块线程在执行临界区代码时必须持有该临界区的引导锁 ，只有申请成功该锁的线程才能够执行相应的临界区，一个线程执行完临界区代码后引导该临界区的锁就会自动释放，在这个过程中内部锁的申请与释放的动作由Java虚拟机负责代为实施，这正是synchronized被称为内部锁的原因。内部锁不会出现锁泄露，因为Javac将同步块代码编译为字节码时，对临界区中可能抛出又未捕获的异常代为处理，使得临界区即使抛出异常也不会阻碍内部锁释放。 显示锁：Lock接口(可重入)默认实现类是java.util.concurrent.lcoks.ReentrantLock，申请相应的显示锁Lock.lock(),try代码为临界区，共享数据后释放锁Lock.unlock(),为了避免锁泄露，将释放锁操作放在finally块中执行123456789private final Lock lock = new ReentrantLock();Public void add()&#123; Lock.lock();Try&#123; Sequence++;&#125;finally&#123; Lock.unlock();&#125;&#125; ReentrantLock的一个构造器如下ReentrantLock(boolean fair)该构造器是的我们创造显式锁时，可以指定是否为公平锁，默认为非公平锁，显式锁可以充分发挥面向对象的灵活性，支持在一个方法里申请锁，在另一个方法里释放锁如果一个内部锁持有线程一直不释放这个锁，那么同步在该锁之上的所有线程都会被暂停使其任务无法进展，而显式锁提供了一个tryLock方法，如果相应的锁未被其他线程持有返回true,否则返回false不会导致其执行线程被暂停123456if(lock.tryLock())&#123; try&#123; &#125;finally&#123; lock.unlock(); &#125;&#125;else 内存屏障可见性可见性：一个线程对共享变量的修改，更够及时的被其他线程看到可见性的保障是由写线程冲刷处理器缓存和读线程刷新处理器缓存动作实现的，在Java锁的获得隐含着刷新处理器缓存这个动作，使得线程在执行临界区前（获得锁后）可以将写线程对共享变量的更新同步到该线程处理器的高速缓存中；而锁的释放隐含着冲刷处理器缓存这个动作，这使得写线程对共享变量的更新能够被“推送”到该线程处理器的高速缓存中，从而对读线程同步。因此锁保障了可见性。前一个动作保证了该所的当前持有线程能够读取到前一个持有线程对这些数据的更新，后一个动作保证了该锁的持有线程对数据的更新对后续持有线程可见。 有序性有序性：程序执行的顺序按照代码的先后顺序执行，可见性是其基础java平台包含两种编译器：静态编译器(javac)动态编译器(JIT),前者是把.java编译为.class(字节码)，后者是把.class动态编译为java虚拟机的本地码(机器码)，他是在java程序运行过程中介入的，可能会导致指令重排序，高速缓存可能会导致储存子系统的重排序串行语义只是保障重排序不影响单线程程序的正确性，有序性保障重排序不影响多线程程序的正确性，可以理解为逻辑上部分禁止重排序，锁保障了临界区内，临界区前，临界区后这3个区域内的任何两个操作都可以在各自的区域范围内进行重排序 内存屏障 按可见性划分可分为加载屏障和储存屏障，加载屏障的作用是刷新处理器缓存，储存屏障的作用是冲刷处理器缓存，Java虚拟机会在释放锁的机器码指令或插入储存屏障，相应的会在申请锁的机器码后插入加载屏障 按有序性来划分可分为获取屏障和释放屏障，获取屏障是在一个读操作之后插入该内存屏障，其作用是禁止该读操作与其后的任何读写操作之间进行重排序，释放屏障的使用方式是在一个写操作之前插入该内存屏障，禁止该写操作与前面的任何读写操作进行重排序，java虚拟机会在MonitorEnter（包含读操作）对应的机器码指令之后临界区之前插入获取屏障，临界区之后MonitorExit(包含写操作)对应的机器码之前插入一个释放屏障。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java线程]]></title>
    <url>%2F2018%2F11%2F28%2Fjava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;在java平台创建一个线程就是创建一个Thread类，每个线程都有要执行的任务，线程的任务处理逻辑可以在Thread类的run方法中直接实现或者通过该方法进行调用，run方法相当于线程的任务处理逻辑的入口方法，由java虚拟机运行线程时直接调用，而不是由代码进行调用，运行一个线程就是让java虚拟机执行该线程的run方法，为此我们首先要启动线程，Thread的start方法的作用是启动相应的线程，启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器决定的，start方法并不意味着相应线程已经开始运行了。 &nbsp;&nbsp;Thread类的两个常用构造器是Thread()和Thread(Runnable target)相应的Java中创建线程的方式有两种，一种是定义Thread类的子类，子类中覆盖run方法，另一种是创建一个java.lang.Runnable接口的实例，以该Runnable接口实例作为构造器的参数直接创建一个Thread类的实例123456789101112131415161718192021222324定义Thread类子类public class WelcomeThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;2.Welcome! I&apos;m &quot; + Thread.currentThread().getName()); &#125;&#125; public static void main(String args[])&#123; Thread welcomeThread = new WelcomeThread(); welcomeThread.start(); System.out.println(&quot;1.Welcome! I&apos;m &quot; + Thread.currentThread().getName()); &#125;Runnable接口public class WelcomeTask implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;2.Welcome! I&apos;m &quot; + Thread.currentThread().getName()); &#125;&#125; public static void main(String args[])&#123; Thread welcomeThread = new Thread(new WelcomeTask()); welcomeThread.start(); System.out.println(&quot;1.Welcome! I&apos;m &quot; + Thread.currentThread().getName()); &#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JPA动态查询]]></title>
    <url>%2F2018%2F11%2F24%2FJPA%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[动态查询是更具面向对象特色的数据查询方式，Hiberbnate放弃了Criteria,Criterion组成的动态条件查询，全面改为使用JPA的动态条件查询 JPAJPA规范本质就是一种ORM规范（对象关系映射Object Relational Mapping ），但并未提供ORM实现只是制定了一些规范，也就是说JPA提供的只是一些接口，Hibernate就是一种ORM实现，下面是JPA的核心API EntityManagerFactory对应Hibernate的SessionFactory EntityManager对应Hibernate的Session EntityTransaction对应Hibernate的TransactionJPA使用类路径下的META-INF子目录中的persistence.xml作为配置文件，格式如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;persistence version=&quot;2.1&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd&quot;&gt; &lt;!-- 为持久化单元指定名称，并通过transaction-type指定事务类型 transaction-type属性合法的属性值有JTA、RESOURCE_LOCAL两个--&gt; &lt;persistence-unit name=&quot;query_pu&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; &lt;!-- 指定该API使用hibernate作为实现 --&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;!-- 列出该应用需要访问的所有的Entity类, 也可以用&lt;mapping-file&gt;或&lt;jar-file&gt;元素来定义 --&gt; &lt;class&gt;org.crazyit.app.domain.Course&lt;/class&gt; &lt;class&gt;org.crazyit.app.domain.Enrolment&lt;/class&gt; &lt;class&gt;org.crazyit.app.domain.Student&lt;/class&gt; &lt;!-- properties元素用于为特定JPA实现包配置属性 --&gt; &lt;!-- 下面列举的是Hibernate JPA实现中可以配置的部分属性 --&gt; &lt;properties&gt; &lt;!-- 指定连接数据库的驱动名 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- 指定连接数据库的URL --&gt; &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://10.204.17.116/hibernate?useSSL=true&quot;/&gt; &lt;!-- 指定连接数据库的用户名 --&gt; &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt; &lt;!-- 指定连接数据库的密码 --&gt; &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;123456&quot;/&gt; &lt;!-- 指定连接数据库的方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;/&gt; &lt;!-- 指定连接池里连接的超时时长 --&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot; value=&quot;5000&quot;/&gt; &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot; value=&quot;100&quot;/&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot; value=&quot;3000&quot;/&gt; &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;hibernate.c3p0.validate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;!-- 设置是否格式化SQL语句 --&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;!-- 设置是否根据要求自动建表 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 动态查询由如下三个类完成 CriteriaBuilder:工厂类，可创建Predicate(代表一个查询条件)，Expression(代表表达式)，CriteriaQuery,CriteriaUpdate,CriteriaDelete Root: 代表要查询的根实体 Join: 代表一个关联CriteriaQuery用于将一条select语句分开成不同的方法可以对不同的子句进行动态组合123456789101112131415161718final static EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;query_pu&quot;);// 打开EntityManager和事务EntityManager em = emf.createEntityManager();em.getTransaction().begin();CriteriaBuilder builder = em.getCriteriaBuilder();// 创建CriteriaQuery，传入的类型参数代表该条件查询返回结果集里的元素类型CriteriaQuery&lt;Student&gt; criteria = builder.createQuery(Student.class);// 设置要查询的根实体类Root&lt;Student&gt; root = criteria.from(Student.class);// 下面语句不是必须的，条件查询默认会查询唯一的Root实体criteria.select(root);// 使用builder生成查询条件，greaterThan可换成其他条件Predicate pred = builder.greaterThan(root.get(Student_.name), &quot;a&quot;); // ①// 使用CriteriaQuery的where()方法添加查询条件criteria.where(pred);List&lt;Student&gt; list = em.createQuer(criteria).getResultList(); 上面的代码中有一个Student_类，他并不是我们定义的Student实体,而是JPA元模型引用所提供的类，JPA会为所有的实体类都提供一个元模型类，元模型通常就是实体类的类名下加下划线，Hibernate为JPA元模型提供了支持，将Hibernate的lib下的jap-metamodel-generator目录下的JAR包导入应用的类型加载路径下，Hibernate会在编译实体时自动为每个实体生成对应的元模型类，具体操作为右键项目选中properties-&gt;java Compiler-&gt;Annotation Procession -&gt;Factory Path然后添加jar包 执行DML语句CriteriaBuilder提供CriteriaUpdate、CriteriaDelete来执行DML语句123456789CriteriaUpdate&lt;Student&gt; update = builder .createCriteriaUpdate(Student.class);Root root = update.from(Student.class);update.set(root.get(Student_.name), &quot;新名字&quot;);Predicate pred = builder.greaterThan( root.get(Student_.studentNumber), 20050230);update.where(pred);int result = em.createQuery(update) .executeUpdate(); 元组查询如果需要查询多个属性或多个实体的组合则建议用CriteriaQuary的multiselect(),JPA还提供了一个Tuple接口专门用于封装多个属性1234567891011121314CriteriaQuery&lt;Tuple&gt; criteria = builder.createQuery(Tuple.class);Root root = criteria.from(Enrolment.class);Path&lt;Integer&gt; yearPath = root.get(Enrolment_.year);Path&lt;Integer&gt; semesterPath = root.get(Enrolment_.semester);criteria.multiselect(yearPath, semesterPath);Predicate pred = builder.gt(root.get(Enrolment_.enrolmentId), 2);criteria.where(pred);List&lt;Tuple&gt; list = em.createQuery(criteria).getResultList();for(Tuple tuple : list)&#123; // 通过元组来获取各属性的值System.out.println(tuple.get(yearPath) + &quot;-&gt;&quot;+ tuple.get(semesterPath)); &#125; 关联查询使用Join API建立关联查询12setJoin&lt;Student, Enrolment&gt; ecrolJoin = root.join(Student_.enrolments, JoinType.LEFT);builder.gt(ecrolJoin.get(Enrolment_semester),2); 使用Fetch进行关联,查询一个实体将其相关联的实体也查出来1Fetch&lt;Student, Enrolment&gt; enrolFetch = root.fetch(Student_enrolments, joinType.LEFT);]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HQL]]></title>
    <url>%2F2018%2F11%2F22%2FHQL%2F</url>
    <content type="text"><![CDATA[HQL全称Hibernate Query Langeage接近于SQL语句，SQL操作对象是数据表，HQL操作对象是类，属性 HQL查询使用Session的createQuery(hql,Class)创建一个Query对象，Query对象使用setParameter()为HQL语句赋值，最后调用getResultList()返回查询结果12345List&lt;Person&gt; p1 = session.createQuery(&quot;select distinct p from Person p join p.myEvents where title = :eventTitle&quot;,Person.class);.setParameter(&quot;eventTitle&quot;, &quot;普通的事&quot;).getResultList();for(Person p : p1) System.out.println(p.getName()); 这种语法类似于PreparedStatement的executeUpdate()语法，推荐使用占位符?N(问号加索引)相应的setParameter(“1”,value);也可用‘:’+参数名字赋值如上 关联和连接分为显示连接和隐式连接，隐式连接转化为SQL的交叉连接（笛卡尔积），显示连接转化为SQL的inner join、left join、right join等，Hibernate只会对实体的普通组件属性和单个关联实体自动使用隐式连接，对于集合属性只能使用显式连接，显式连接可用with提供额外的连接条件1form Person p inner join p.myEvent event with p.id &gt; enevt.id 隐式查询1234form Person p where p.myEvent.title&gt;:title将转换成下列SQL语句select ... from person_inf person0_ crossjoin event_inf myevent1_ where person0_event_id=myevent1_.event_id and myevent1.title&gt;? 命名查询将HQL语句从java中提取出来，放到注解中配置，使用@NameQuary(name = “名称”, query = “HQL语句”)如果放在XML注解中&lt;query name=&quot;&quot;&gt; HQL语句&lt;/query&gt; DML风格批量更新|删除HQL支持批量update和delete,格式如下1update | delete from? &lt;Classname&gt; [where where_conditions] from子句可选，可以不写 from子句只能有一个类名，可为该类名指定别名 不能在批量HQL语句中使用连接，可以在where子句中使用子查询 where子句可选批量操作如下123456789//更新String hqlUpdate = &quot;update User u set name = :newName&quot;;int updateEntities = session.createQuery(hqlUpdate).setParameter(&quot;newName&quot;,&quot;新名字&quot;);.executeUpdate();//删除String hqlUpdate = &quot;delete User&quot;;int deleteEntities = session.createQuery(hqlUpdate).executeUpdate();]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个Hibernate]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AC%AC%E4%B8%80%E4%B8%AAHibernate%2F</url>
    <content type="text"><![CDATA[Hibernate是javaEE的持久层解决方案，可以管理Java类到数据库的映射，还提供数据查询和获取数据 的方法，Hibernate完成了对象模型和基于SQL的关系模型的映射关系，使得开发者可以完全采用面向对象的方式来开发应用程序，所谓的持久层是指向储存器中储存数据的一组类和组件，是一个相对独立的逻辑层面。 持久化对象(PO)News类12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity@Table(name=&quot;news_inf&quot;)public class News&#123; // 消息类的标识属性 @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 消息标题 private String title; // 消息内容 private String content; // id的setter和getter方法 public void setId(Integer id) &#123; this.id = id; &#125; public Integer getId() &#123; return this.id; &#125; // title的setter和getter方法 public void setTitle(String title) &#123; this.title = title; &#125; public String getTitle() &#123; return this.title; &#125; // content的setter和getter方法 public void setContent(String content) &#123; this.content = content; &#125; public String getContent() &#123; return this.content; &#125;&#125; News本身是一个普通的JavaBean,为他加上持久化注解就变成了持久化对象PO=POJO（普通传统Java对象）+持久化注解 @Entity注解声明该类是个Hibernate持久化类 @Table注解指定该类映射的数据表 @Id指定该类的标识属性 @GeneratedValue(strategy=GenerationType.IDENTITY)用于主键的生成策略Hibernate的XML配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定连接数据库所用的驱动 --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 指定连接数据库的url，其中hibernate是本应用连接的数据库名 --&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost/hibernate?useSSL=true&lt;/property&gt; &lt;!-- 指定连接数据库的用户名 --&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;!-- 指定连接数据库的密码 --&gt; &lt;property name=&quot;connection.password&quot;&gt;32147&lt;/property&gt; &lt;!-- 指定连接池里最大连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt; &lt;!-- 指定连接池里最小连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;1&lt;/property&gt; &lt;!-- 指定连接池里连接的超时时长 --&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;5000&lt;/property&gt; &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/property&gt; &lt;!-- 指定数据库方言 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 根据需要自动创建数据表 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;&lt;!--①--&gt; &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 将SQL脚本进行格式化后再输出 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 罗列所有持久化类的类名 --&gt; &lt;mapping class=&quot;org.crazyit.app.domain.News&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; &lt;!DOCTYPE&gt;一个文档类型标记，它的目的是要告诉通用标记语言解析器，他应该使用什么样的文档类型定义（DTD）来解析文档，Hibernate配置文件的默认文件名为hibernate.cfg.xml，当程序调用Configuration对象的configure()方法时会自动加载该文件，Hibernate推荐使用C3P0数据源，数据源会负责维持一个数据连接池，当程序创建数据源实例时，系统会一次性创建多个数据库连接，并保存在连接池中 完成消息插入的代码12345678910111213141516171819202122232425262728293031public class NewsManager&#123; public static void main(String[] args) throws Exception &#123; // 实例化Configuration Configuration conf = new Configuration() // 不带参数的configure()方法默认加载hibernate.cfg.xml文件 // 如果传入abc.xml作为参数，则不再加载hibernate.cfg.xml，改为加载abc.xml .configure(); // 以Configuration实例创建SessionFactory实例 SessionFactory sf = conf.buildSessionFactory(); // 创建Session Session sess = sf.openSession(); // 开始事务 Transaction tx = sess.beginTransaction(); // 创建消息对象 News n = new News(); // 设置消息标题和消息内容 n.setTitle(&quot;疯狂Java联盟成立了&quot;); n.setContent(&quot;疯狂Java联盟成立了，&quot; + &quot;网站地址http://www.crazyit.org&quot;); // 保存消息 sess.save(n); // 提交事务 tx.commit(); // 关闭Session sess.close(); sf.close(); &#125;&#125; Configuration负责加载Hibernate配置文件 SessionFactory是数据库编译后的内存镜像，通常一个应用对应一个SessionFactory， Session是应用程序和持久储存层之间交互操作和一个单线程对象，所有的持久化对象必须在session管理下才可以进行持久化操作，生存期很短，它底层封装了JDBC连接，他也是Transaction的工厂，Session对象持有必选的一级缓存，在显式执行flush之前所有持久化操作的数据都在缓存中的session对象处 Transaction(事务)代表一次原子操作，它具有数据库事务的概念，所有的持久化操作都应该在事务管理下进行]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitHub新手教程]]></title>
    <url>%2F2018%2F10%2F30%2FGitHub%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[先在GitHub上创建一个库,安装Git Bash软件，第一次使用需要在你的电脑获得一个密钥，在Git Bash中输入1$ ssh-keygen-t rsa-C &quot;your_email@youremail.com&quot; 然后在/Users/pc下找到.ssh下的id_rsa，复制其中的密钥放到你GitHub库中：点击Github项目右上角的下拉菜单setting找到SSH and GPG keys把密钥放上，然后回到Git Bash上输入123$ ssh -T git@github.com$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot; 接下来将库克隆到本地电脑1git clone https://github.com/HananiJia/test.git git clone后面的网址就是创建库成功之后的网址，生成的这个文件夹有一个.git文件把你想要上传的文件放到这个文件夹下，然后定位到这个文件夹下，然后输入123git add test.txtgit commit -m &quot;备注&quot;git push origin master master可以替换为任何分支]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Convention插件与约定支持]]></title>
    <url>%2F2018%2F10%2F23%2FConvention%E6%8F%92%E4%BB%B6%E4%B8%8E%E7%BA%A6%E5%AE%9A%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Struts2引入了Convention来支持零配置，不需要sturts.xml进行配置，而是根据约定来自动配置 Action的搜索和映射约定Convention插件会自动搜索action,actions,sturts,struts2包下所有的java类Convention会把下两种Java当成Action处理 所有实现com.opensymphony.xwork2.Action的Java类 所有类名以Action结尾的Java类映射Action的name时： 如果Action类名包含Action后缀,将后缀去掉，否则不做任何处理 将Action类名的驼峰写法转换成中划线写法例如GetBooks映射为get-books例如将org.crazyit.app.action.user;LoginAction将表单定义为&lt;s:form action=”/user/login”&gt;按约定映射Result默认情况下Convention总会到web应用的WEB-INF/content路径下定位物理资源，定位资源的约定是actionName+resultcode+suffix当找不到对应的视图资源时，Convention会自动试图使用action+suffix作为视图资源例如org.crazyit.app.action.user.LoginAction返回success字符串时，优先考虑login-success.jsp如果找不到该文件，login.jsp也可作为对应视图资源Config Browser插件复制strut2-config-browser-plugin-2.5.14.jar复制到WEB-INF\lib下然后输入地址http://localhost:8080/web项目名/config-browser/actionNames.actionAction链的约定如果希望一个Action处理结束后不是进入视图界面而是进入另一个Action形成Action链只需要遵循下面三个约定 第一个Action返回的逻辑视图字符串没有对应的视图资源 第二个Action与第一个Action处于同一个包下 第二个Action的映射URL为：firstactionName+resultcode如FirstAction返回”second”第二个Action为FirstSecondAction]]></content>
      <categories>
        <category>struts</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个struts2工程]]></title>
    <url>%2F2018%2F10%2F15%2F%E7%AC%AC%E4%B8%80%E4%B8%AAstruts2%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[struts2是一个优秀的MVC框架，减少了耦合增加了可扩展性。 添加JAR包将Struts2的lib目录下的JAR包复制到应用的/WEB-INF/lib下 web.xml配置该框架的核心Filter来拦截用户请求，让该框架介入Web应用12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Struts 2的核心Filter拦截所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; struts.xml核心配置文件放在eclipse的src下，Struts2默认配置文件为struts.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;mess&quot;/&gt; &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot;/&gt; &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt; &lt;!-- 所有的Action定义都应该放在package下 --&gt; &lt;package name=&quot;lee&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot; strict-method-invocation=&quot;false&quot;&gt; &lt;action name=&quot;login&quot; class=&quot;org.crazyit.app.action.LoginAction&quot;&gt; &lt;result name=&quot;error&quot;&gt;/WEB-INF/content/error.jsp&lt;/result&gt; &lt;result name=&quot;success&quot;&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;package name=&quot;crazyit&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;*&quot;&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; JSP页面1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;&lt;s:text name=&quot;loginPage&quot;/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;s:form action=&quot;login&quot;&gt; &lt;s:textfield name=&quot;username&quot; key=&quot;user&quot;/&gt; &lt;s:textfield name=&quot;password&quot; key=&quot;pass&quot;/&gt; &lt;s:submit key=&quot;login&quot;/&gt;&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; Action类处理用户请求，作为控制器调用Model里的方法来处理请求，MVC通过反射来创建Action123456789101112131415161718192021222324252627282930package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;public class LoginAction &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String execute () throws Exception &#123; if(getUsername().equals(&quot;crazyit.org&quot;)&amp;&amp; getPassword().equals(&quot;leegang&quot;)) &#123; ActionContext.getContext().getSession().put(&quot;user&quot;, getUsername()); return &quot;success&quot;; &#125; return &quot;error&quot;; &#125;&#125; 国际化资源mess_zh_CN.propeties放在scr下12345678loginPage=登录页面errorPage=错误界面succPage=成功界面failTip=对不起，您不能登录！succTip=欢迎user=用户名pass=密码login=登录]]></content>
      <categories>
        <category>struts</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于eclipse的web工程标注无效]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%85%B3%E4%BA%8Eeclipse%E7%9A%84web%E5%B7%A5%E7%A8%8B%E6%A0%87%E6%B3%A8%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[在eclipse里开发web项目时在使用servlet3.0的标注时我遇到了注释无效的问题，解决办法是在部署完项目到webapps后，右键项目的Export选择War File导入到tomcat的webapps下就能使用了]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Eclipse添加用户库]]></title>
    <url>%2F2018%2F10%2F10%2FEclipse%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%BA%93%2F</url>
    <content type="text"><![CDATA[添加用户库是为了方便管理多个JAR文件，例如在添加Hibnate和Struts时会很方便右键项目节点，单击”Build Path” -&gt; “Configure Build Path…”,在出现的对话框中选中”User Library”,并单击”next”,在右边选中”User Library”,如需要新增用户库就单击”New”,选中要编辑的用户库的名字，然后单击”Add External JARS”]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql正则表达式]]></title>
    <url>%2F2018%2F10%2F08%2Fmysql%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[连接mysql:mysql -h+ip -uroot -p+密码Mysql仅支持正则表达式的一个子集，关键字为REGEXP类似于Mysql的like,不同在于like仅当字符完全匹配才返回数据而REGEXP如果列值出现匹配文本就返回数据 ##OR匹配用’|’,匹配多个字符时可用[123]为[1|2|3]的缩写[^123]为除123以外 ##匹配范围[1-9],[a-z]匹配是默认不区分大小写的，可使用BINATY关键字如where name REGEXP BINARY ‘Li ‘ 匹配特殊字符对特殊字符转义用\为前引12345\\f 换页\\n 换行\\r 回车\\t 制表\\v 纵向制表 匹配字符类12345678[:alnum:] 任意字母和数字[:alpha:] 任意字母[:blank:] 空格和制表[:digit:] 任意数字[:lower:] 任意小写字母[:upper:] 任意大写字母[:print:] 任意可打印字符[:space:] 任意空白字符 匹配多个实例123456* 多个匹配+ 1个或多个匹配？ 0个或1个匹配&#123;n&#125; 指定数目的匹配&#123;n,&#125; 不少于指定数目的匹配&#123;n,m&#125; 匹配数目的范围 例如where name REGEXP ‘\([0-9] sticks?\)’s后的?使s变得可选可匹配stricks或stick ##定位符1234^ 文本的开始$ 文本的结束[[:&lt;:]] 词的开始[[:&gt;:]] 词的结束]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F09%2F26%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Java反射主要提供以下功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法(private方法也可以) 在运行时调用任意一个对象的方法 获取Class对象的三种方式1234567Student stu = new Student();//调用某个对象的getclass方法1.Class stuClass = stu.getClass()//直接获取某一个对象的class2.Class stuClass = Student.class;//Class类的静态方法3.Class stuClass = Class.forname(包名.类名); 在运行期间一个类只能产生一个Class对象 判断是否为某个类的实例public native boolean isInstance(Object obj)class.isInstance(obj); 创建实例 Class对象的newInstance()方法类创建Object object = class.newInstance(); 先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例 1234//先获取无参数构造器Constructor con = c.getConstructor(null);//根据构造器创建实例Object object = con.newInstance(参数); 获取方法123456//所有公共方法Method methodArray[] = class.getMethods();//所有方法class.getDeclaredMethods();//show(String s)class.getMethod(&quot;show&quot;, String.class); 获取构造器信息123456//公有构造方法Constructo[] conArray = class.getConstructors();//所有构造方法class.getDeclaredConstructors();//带一个string类型构造器class.getConstructor(String.class); 获取类的成员变量12345class.getFields();公有的成员变量class.getDeclaredField();所有成员变量Field f = class.getFilds(&quot;name&quot;)Object obj = class.getConstructor().newInstance();f.set(obj,&quot;&quot;) 调用方法12Object object = class.getConstructor().newInstance();Object result = method.invoke(obj,&quot;&quot;);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绿色计算大赛文件查看器]]></title>
    <url>%2F2018%2F09%2F25%2F%E7%BB%BF%E8%89%B2%E8%AE%A1%E7%AE%97%E5%A4%A7%E8%B5%9B%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[编写代码实现对给定文件夹目录结构的展示，如果文件的英文夹数则在其名字之前加上+–若是文件则加上–，上级目录与下级目录，文件下级用两个空格作为间隔 123456789101112131415161718192021import java.io.File;public class Task &#123; /********** BEGIN **********/ public void showDirStructure(File file) &#123; System.out.println(&quot;+--&quot; + file.getName()); showDirTree(file,&quot; &quot;); &#125; public static void showDirTree(File dir,String interval)&#123; File[] files = dir.listFiles(); interval += &quot; &quot;; for (File file : files) &#123; if(!file.isDirectory())&#123; System.out.println(interval + &quot;--&quot; + file.getName()); &#125;else&#123; System.out.println(interval + &quot;+--&quot; + file.getName()); showDirTree(file,interval + &quot; &quot;); &#125; &#125; &#125; /********** END **********/&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode链表中倒数第k个节点]]></title>
    <url>%2F2018%2F09%2F25%2FLeetcode%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[输入一个链表，输出该链表中倒数第k个节点 分析：采用单循环用两个指针,一个节点node1先开始跑，指针node1跑到k-1个节点后，另一个节点node2开始跑,当node1跑到终点node2就是倒数第k个节点1234567891011121314151617181920212223242526272829public class ListNode&#123; int val; ListNode next; ListNode(int x) &#123;val = x; &#125;&#125;public class Solution &#123; public ListNode FindKthToTail(ListNode head, int k) &#123; //如果链表为空或k&lt;=0 if(head == null || k &lt;= 0) &#123; return null; &#125; ListNode node1 = head , node2 = head; int count = 0; int index = k; while (node1 != null) &#123; node1 = node1.next; count ++; if (k &lt; 1 &amp;&amp; node1 != null) &#123; node2 = node2.next; &#125; k--; &#125; if(count &lt; index) return null; return node2; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode反转链表]]></title>
    <url>%2F2018%2F09%2F24%2FLeetcode%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[输入一个链表，反转后输出所有元素123456789101112131415161718192021public class ListNode&#123; int val; ListNode next; ListNode(int x) &#123;val = x; &#125;&#125;public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode next = null; ListNode pre = null; while(head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode链表两数相加]]></title>
    <url>%2F2018%2F09%2F23%2FLeetcode%E9%93%BE%E8%A1%A8%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目：给定两个非空链表来表示两个非负整数，位数按照逆序方式储存，它们的每个节点只储存单个数字，将两数相加返回一个新的链表示例：(2-&gt;4-&gt;3)+(5-&gt;6-&gt;4)(7-&gt;0-&gt;8)123456789101112131415161718192021222324252627282930public class ListNode&#123; int val; ListNode next; ListNode(int x) &#123;val = x; &#125;&#125;public class Solution &#123; public ListNode addTwoNumbers(ListNode l1,ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1 , q = l2 , curr = dummyHead; //carry表示进位数 int carry = 0; while(p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum%10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[直接插入排序:将一条记录插入到已排好的有序表中，得到一个新的有序表123456789101112131415int a[]=&#123;98,76,109,34,67,190,80,12,14,89,1&#125;;int k=sizeof(a)/sizeof(a[0]);int j;for(int i=1;i&lt;k;i++)//循环从第2个元素开始&#123; if(a[i]&lt;a[i-1]) &#123; int temp=a[i]; for(j=i-1;j&gt;=0 &amp;&amp; a[j]&gt;temp;j--) &#123; a[j+1]=a[j]; &#125; a[j+1]=temp;//此处就是a[j+1]=temp; &#125;&#125; 冒泡排序:只比较相邻数字，下一次循环比较次数减一1234567891011121314void bubble_sort(int a[], int n)&#123; int i, j, temp; for (j = 0; j &lt; n - 1; j++) for (i = 0; i &lt; n - 1 - j; i++) &#123; if(a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; &#125; &#125;&#125; 简单选择排序:找出每趟最小的数与第i个交换，n-1趟后完成排序123456789101112131415int a[10],i,j,k,t;for(i=0;i&lt;10;i++)&#123; t=i; for(j=i+1;j&lt;10;j++) &#123; if(a[t]&gt;a[j]) &#123; t=j &#125; &#125; int temp = a[i]; a[i]=a[t]; a[t]=temp;&#125; 归并排序：将已有序的子序列合并，得到完全有序序列这个代码就有点些复杂了，首先把一个序列不断划分子序列1234567891011void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)&#123; int midIndex; if(startIndex &lt; endIndex) &#123; midIndex = startIndex + (endIndex-startIndex) / 2;//避免溢出int MergeSort(sourceArr, tempArr, startIndex, midIndex); MergeSort(sourceArr, tempArr, midIndex+1, endIndex); Merge(sourceArr, tempArr, startIndex, midIndex, endIndex); &#125;&#125; 然后就是如何合并子序列,temp只是一个用来暂时存放数据的数组例如：5678 1234合并一个指针i在5一个指针j在1还有个临时指针k直到前子序列和后子序列有一个已经合并完成，将另一个直接放到temp里1234567891011121314151617void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)&#123; int i = startIndex, j=midIndex+1, k = startIndex; while(i!=midIndex+1 &amp;&amp; j!=endIndex+1) &#123; if(sourceArr[i] &gt; sourceArr[j]) tempArr[k++] = sourceArr[j++]; else tempArr[k++] = sourceArr[i++]; &#125; while(i != midIndex+1) tempArr[k++] = sourceArr[i++]; while(j != endIndex+1) tempArr[k++] = sourceArr[j++]; for(i=startIndex; i&lt;=endIndex; i++) sourceArr[i] = tempArr[i];&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于XML Schema的简化配置]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%9F%BA%E4%BA%8EXML-Schema%E7%9A%84%E7%AE%80%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[从Spring2.0以来Spring允许使用XML Schema的配置方式来简化Spring配置文件，这种方式更加简洁,好好享用这份蜜糖 使用p:命名空间简化配置设置注入12345&lt;property name=&quot;axe&quot; ref=&quot;stoneAxe&quot;/&gt;&lt;property name=&quot;age&quot; value=&quot;29&quot;/&gt;//使用p:导入XML Schema里的p:命名空间xmlns:p=&quot;http://www.springframework.org/&lt;bean id= class= p:age=&quot;29&quot; p:axe-ref=&quot;stoneAxe&quot;/&gt; 使用c：命名空间简化构造注入可以直接使用属性来配置构造器1234567&lt;constructor-arg ref=&quot;steelAxe&quot;/&gt;&lt;constructor-arg value=&quot;29&quot;/&gt;使用c:xmlns:c=&quot;http://www.springframework.org/&lt;bean id= class= c:axe-ref=&quot;steelAxe&quot; c:age=29/&gt;也支持使用索引来配置构造器&lt;bean id= class= c:_0-ref=&quot;steelAxe c:_1=&quot;29&quot;/&gt; 使用util:命名空间简化高级依赖关系配置获取其他Bean的属性值1234567&lt;bean id= class=&gt;&lt;!-- 获取id=person的getson()方法 --&gt;&lt;property name=&quot;targetBeanName&quot; value=&quot;person&quot;/&gt;&lt;property name=&quot;propertyPath&quot; value=&quot;son&quot;/&gt;&lt;!-- 简化后 --&gt;&lt;util:property-path id= path=&quot;person.son&quot;/&gt;&lt;/bean&gt; 获取Field值1234567&lt;property name=&quot;tagetClass&quot; value=&quot;java.sql.Connection&quot;/&gt;&lt;property name=&quot;tagetField&quot; value=&quot;TRANSACTION_SERIALIZABLE&quot;&gt;使用util:获取Field值xmls:util=&quot;http://www.springframework.org/schema/util&quot;&lt;util:constant static-field=&quot;java.sql.Connection.TRANSACTION_SERIALIZABLE&quot;/&gt; 集合集1234567891011121314&lt;property name=&quot;schools&quot;&gt; &lt;list&gt; &lt;value&gt;小学&lt;/value&gt; &lt;value&gt;中学&lt;/value&gt; &lt;value&gt;大学&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;简化后p:schools-ref=&quot;chin.schools&quot;&lt;util:list id=&quot;chin.schools&quot; list-class=&quot;java.util.LinkedList&quot;&gt; &lt;value&gt;小学&lt;/value&gt; &lt;value&gt;中学&lt;/value&gt; &lt;value&gt;大学&lt;/value&gt;&lt;/util:list&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或2级台阶，求一共有多少种走法，经典的动态规划问题动态规划当中包含三个重要的概念：最优子结构，边界，状态转移公式对于这题最优子结构为F(10)=F(9)+F(8),边界为F(1)和F(2),状态转移方程为F(N)=F(N-1)+F(N-2),由此得递归函数123456int getClimbingWays(int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; if(n==2) return 2; return getClimbingWays(n-1) + getClimbingWays(n-2)&#125; 接下来对该函数进行时间优化,用map来存储信息，也就是备忘录算法123456789101112int getClimbingWays(Map&lt;Integer,Integer&gt; map,int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; if(n==2) return 2; if(map.containsKey(n))&#123; return map.get(n); &#125;else&#123; int value = getClimbingWays(map,n-1)+getClimbingWays(map,n-2); map.put(n,value); return value;&#125;&#125; 上述算法都是自顶向下计算，这次换成自底向上计算，也就是动态规划算法1234567891011121314int getClimbingWays(int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; if(n==2) return 2; int a = 1; int b = 2; int temp = 0; for(int i=3;i&lt;=n;i++)&#123; temp = a+b; a = b; b = temp; &#125; return temp;&#125; 时间复杂度为o(n)空间复杂度为o(1)实现了最优化，这就是动态规划题目二：国王和金矿10个工人，5个金矿分别为500金/5人，200金/3人，300金/4人，350/3人，400金/5人分析：最优子结构有两个一个是4金矿10个人，一个是4金矿10-3人时，边界是只有一座金矿和给定的工人不够第一座金矿，设金矿数量为n,工人数为w黄金量为g[],金矿的用工量为p[]12345678910111213141516int getMostGold(int n,int w,int[] g ,int []p)&#123; int[] preResults = new int[p.length]; int[] results = new int[p.length]; for(int i=0;i&lt;=n;i++)&#123; if(i&lt;p[0]) preResults[i] = 0; else preResults[i] = g[0]; &#125; for(int i=0;i&lt;=w;i++)&#123; for(int j=0;j&lt;=w;j++)&#123; if(j&lt;p[i]) results[j] = preResults[j]; else results[j] = Math.max(reResults[j],preResults[j-p[i]+g[i]]); &#125; preResults = results; &#125; return results[n];&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lintcode:尾部的零]]></title>
    <url>%2F2018%2F09%2F17%2Flintcode%E5%B0%BE%E9%83%A8%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[题目：计算出n阶乘中尾部零的个数1、2、3、4、5、6、7、8、9、10、11…、5…、10…、15…、20…、25…这些数中每5个产生一个0，化简成5k…、25…50…75…100…125…将其中k=5,10,15,20又能产生一个0，由此递归得123456while(n)&#123; num += n / 5; n = n / 5;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 解题关键在于如何解决25的倍数这些数，细心观察化简为5k后规律是一致的]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lintcode:a+b]]></title>
    <url>%2F2018%2F09%2F16%2Flintcode-a-b%2F</url>
    <content type="text"><![CDATA[题目：不用+等运算符运算实现加法思路很明确就是用二进制来运算,1.and运算&amp;相同位的两个数字为一则为1，如有一个不为1则为02.or运算|相同位只要有一个1即为13.xor异或运算^相同位不同则为1，相同为01的二进制….00012的二进制….00103的二进制….00114的二进制….0100由此我们可以推测出不进位时a+b=a|b,需要进位时先计算a^b，再计算应该进位的值(a&amp;b)&lt;&lt;1,递归调用12345int aplusb(int a, int b) &#123; if((a&amp;b) == 0) return a|b; return aplusb(a^b,(a&amp;b)&lt;&lt;1);&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo命令]]></title>
    <url>%2F2018%2F09%2F16%2Fhexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用网站集]]></title>
    <url>%2F2018%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 大连民族大学 tags:This article is just to test my blog,welcome伟大的背后都是苦难高清壁纸网站贴图库图片外联绿色计算机大赛在线绘图在线转码csdnlintCode刷题leetcode刷题]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
